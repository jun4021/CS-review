# 자료구조개론

1. Stack, Queue
2. Priority Queue
3. Tree
4. Graph
5. Sorting

## 1. Stack, Queue
### Stack
```Last In First Out```

```Top```만 호출 가능
### Queue
```First In First Out```

들어간 순서대로 호출 가능

### 2. Priority Queue
```Heap```을 이용한 우선순위에 따라 정렬되는 ```Queue```

### Heap
* 완전 이진트리를 이용한 최대(최소)를 빠르게 찾는 데 특화 된 자료구조.
* 노드 삽입 시 ```O(log n)```으로 새로운 노드는 부모 노드와 크기를 비교하여 위치를 잡아간다. 
* 노드 삭제 시(루트 노드) 마지막 노드를 루트로 가져와 삽입과 마찬가지로 위치를 잡는다.

## 3. Tree
### Binary Tree
루트 노드를 기준으로 두개 이하의 서브 트리를 갖는 자료구조
탐색 연산은 ```O(h)```로 트리의 높이와 관련되어 있다.


## 4. Graph
### 구현 방법

1. 인접 행렬

```vertex``` 끼리의 ```weight``` 값을 각 행렬의 요소로 갖는다. ```Edge``` 수에 무관하나 ```Matrix```의 크기가 ```V^2``` 로 매우 크다.

2. 인접 리스트

한 ```vertex```의 인접한 ```vertex```를 확인 가능하며 ```E+V``` 로 비교적 적은 메모리를 차지한다. 단, weight 표기에 별도의 노력이 필요하다.
### 탐색
1. DFS

```Stack``` 자료구조 or 재귀를 사용하여 구현.

2. BFS

```Queue``` 자료구조를 사용하여 구현. 최단 경로를 보장한다.

## 5. Hash table (http://egloos.zum.com/sweeper/v/925740)
특정 hash 함수를 이용하여 고정된 길이의 데이터로 매핑
모든 데이터를 탐사하는 속도는 떨어지지만 특정 데이터를 찾는데 특화.
- Collision 발생 해결 방안
  - Chaining : 연결리스트를 활용하여 저장한다. 삽입은 용이하나 탐색, 삭제가 어려울 수 있음.
  - Open Addressing : 다른 비어있는 주소를 탐사하여 삽입한다. 
    - 선형 탐사 : 인접한 인덱스 먼저 탐사.
    - 제곱 탐사 : n^2 차례로 탐색.
    - 이중 해싱 : 두번째 hash 함수를 이용하여 충돌 시 다음 탐사 인덱스를 계산한다.

